# Path: titan/schemas/plan.py
from __future__ import annotations
from typing import Dict, Any, List, Optional
from pydantic import BaseModel, Field
from enum import Enum
from uuid import uuid4
import time

# FIX: Ensure we only import the modernized classes
from .graph import CFG, CFGNodeType, CFGNode # CFGNode, CFGNodeType, CFG are the current classes
from .events import Event  # Assuming Event schema exists
from .task import Task # Assuming Task schema exists

class PlanStatus(str, Enum):
    """
    Defines the lifecycle status of a Plan.
    """
    CREATED = "created"
    READY = "ready"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

def new_plan_id(prefix: str = "plan") -> str:
    return f"{prefix}_{uuid4().hex[:8]}"

class Plan(BaseModel):
    """
    The central, executable Plan object produced by the Planner subsystem.
    It contains the compiled Control Flow Graph (CFG) and metadata.
    """
    id: str = Field(default_factory=new_plan_id)
    user_input: str
    session_id: str
    status: PlanStatus = PlanStatus.CREATED
    
    # Core components generated by the DSL compiler pipeline
    cfg: CFG = Field(description="The compiled Control Flow Graph.")
    
    # Metadata and source tracking
    created_at: float = Field(default_factory=time.time)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    # Optional provenance data (e.g., initial DSL text and AST structure)
    source_dsl: Optional[str] = Field(None, description="The raw DSL text generated by the LLM.")
    source_ast: Optional[Dict[str, Any]] = Field(None, description="The structural dump of the Abstract Syntax Tree.")
    
    # Task Definitions (map Task ID to Task object, used by TaskNodes)
    tasks: Dict[str, Task] = Field(default_factory=dict, description="A dictionary of Task definitions used by nodes in the CFG.")
    
    # Execution history summaries (lightweight)
    execution_history: List[Dict[str, Any]] = Field(default_factory=list, description="A list of summary results from the Executor.")
    
    def to_summary(self) -> Dict[str, Any]:
        """Generates a concise summary for logging and events."""
        return {
            "plan_id": self.id,
            "status": self.status.value,
            "session_id": self.session_id,
            "node_count": len(self.cfg.nodes),
            "created_at": self.created_at
        }

    # Add a method to check if the plan is ready for execution
    def is_executable(self) -> bool:
        """A plan is executable if it's in a CREATED or PAUSED state and has a valid CFG."""
        return self.status in [PlanStatus.CREATED, PlanStatus.PAUSED] and self.cfg is not None and self.cfg.entry is not None

# The assumption is that this fix clears the last dependency issue. 
# After replacing this file, please run the test one more time.