# titan/schemas/plan.py
from __future__ import annotations
from typing import Dict, Any, List, Optional
from pydantic import BaseModel, Field
from enum import Enum
from uuid import uuid4
import time

from .graph import CFG
from .task import Task

class PlanStatus(str, Enum):
    CREATED = "created"
    READY = "ready"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

def new_plan_id(prefix: str = "plan") -> str:
    return f"{prefix}_{uuid4().hex[:8]}"

class Plan(BaseModel):
    id: str = Field(default_factory=new_plan_id)
    user_input: Optional[str] = None
    session_id: Optional[str] = None
    status: PlanStatus = PlanStatus.CREATED
    cfg: CFG = Field(description="The compiled Control Flow Graph.")
    created_at: float = Field(default_factory=time.time)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    source_dsl: Optional[str] = Field(None, description="The raw DSL text generated by the LLM.")
    source_ast: Optional[Dict[str, Any]] = Field(None, description="The structural dump of the Abstract Syntax Tree.")
    tasks: Dict[str, Task] = Field(default_factory=dict, description="A dictionary of Task definitions used by nodes in the CFG.")
    execution_history: List[Dict[str, Any]] = Field(default_factory=list, description="A list of summary results from the Executor.")

    model_config = {"extra": "forbid"}

    def to_summary(self) -> Dict[str, Any]:
        return {
            "plan_id": self.id,
            "status": self.status.value,
            "session_id": self.session_id,
            "node_count": len(self.cfg.nodes) if self.cfg and hasattr(self.cfg, "nodes") else 0,
            "created_at": self.created_at
        }

    def is_executable(self) -> bool:
        return self.status in [PlanStatus.CREATED, PlanStatus.PAUSED] and self.cfg is not None and getattr(self.cfg, "entry", None) is not None
