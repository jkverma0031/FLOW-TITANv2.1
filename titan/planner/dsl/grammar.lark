// Path: titan/planner/dsl/grammar.lark
%declare INDENT DEDENT

// --- TOKENS ---
DOT: "."
COMMA: ","
LPAR: "("
RPAR: ")"
EQ: "="
EQEQ: "=="
NEQ: "!="
GT: ">"
LT: "<"
GTE: ">="
LTE: "<="
IN: "in"
OR: "or"
AND: "and"
COLON: ":"

NAME: /[a-zA-Z_]\w*/
NUMBER: /\d+(\.\d+)?/
ESCAPED_STRING: /"[^"\n]*"/
_NEWLINE: /(\r?\n[\t ]*)+/
WS: /[ \t\f]+/

%ignore WS
%ignore /#[^\n]*/

// --- RULES ---

start: (_NEWLINE | stmt)*

?stmt: simple_stmt | compound_stmt

simple_stmt: (assignment | expr_stmt) _NEWLINE

compound_stmt: if_stmt | for_stmt | retry_stmt

assignment: NAME EQ call_expr
expr_stmt: expr

// Note: suite logic relies on explicit INDENT/DEDENT handling
if_stmt: "if" expr COLON suite ["else" COLON suite]
for_stmt: "for" NAME IN expr COLON suite
retry_stmt: "retry" "attempts" EQ NUMBER ["backoff" EQ NUMBER] COLON suite

suite: simple_stmt | _NEWLINE INDENT stmt+ DEDENT

// Expressions - Order of precedence is defined by rule ordering in lark, but we rely on explicit grouping here
expr: or_test

or_test: and_test (OR and_test)*
and_test: comparison (AND comparison)*
comparison: attr_access ((EQEQ | NEQ | GT | LT | GTE | LTE | IN) attr_access)*

// Core fix: Atom can be a value (variable, string, number)
attr_access: atom (DOT NAME)*

atom: call_expr
    | value
    | "(" expr ")"

call_expr: NAME LPAR [arg_list] RPAR
arg_list: arg (COMMA arg)* [COMMA]
arg: NAME EQ expr      -> keyword_arg
   | expr               -> positional_arg

// NEW RULE: Represents literal values/variables for expressions
value: ESCAPED_STRING -> string_value
     | NUMBER         -> number_value
     | NAME           -> name_value